package compiler

import (
  "fmt"
  "github.com/lestrrat/go-xslate/parser"
  "github.com/lestrrat/go-xslate/vm"
)

type Compiler interface {
  Compile(* parser.AST) (*vm.ByteCode, error)
}

type CompilerCtx struct {
  ByteCode *vm.ByteCode
}

func (ctx *CompilerCtx) AppendOp(o vm.OpType, args ...interface {}) *vm.Op {
  return ctx.ByteCode.AppendOp(o, args...)
}

type BasicCompiler struct {}

func New() *BasicCompiler {
  return &BasicCompiler {}
}

func (c *BasicCompiler) Compile(ast *parser.AST) (*vm.ByteCode, error) {
  ctx := &CompilerCtx {
    ByteCode: vm.NewByteCode(),
  }
  for _, n := range ast.Root.Nodes {
    c.compile(ctx, n)
  }

  // When we're done compiling, always append an END op
  ctx.ByteCode.AppendOp(vm.TXOP_end)

  return ctx.ByteCode, nil
}

func (c *BasicCompiler) compile(ctx *CompilerCtx, n parser.Node) {
  switch n.Type() {
  case parser.NodeText:
    // XXX probably not true all the time
    ctx.AppendOp(vm.TXOP_literal, n.(*parser.TextNode).Text)
  case parser.NodeFetchSymbol:
    ctx.AppendOp(vm.TXOP_fetch_s, n.(*parser.TextNode).Text)
  case parser.NodeFetchField:
    ffnode := n.(*parser.FetchFieldNode)
    c.compile(ctx, ffnode.Container)
    ctx.AppendOp(vm.TXOP_fetch_field_s, ffnode.FieldName)
  case parser.NodeLocalVar:
    l := n.(*parser.LocalVarNode)
    ctx.AppendOp(vm.TXOP_load_lvar, l.Offset)
  case parser.NodeAssignment:
    c.compile(ctx, n.(*parser.AssignmentNode).Expression)
    ctx.AppendOp(vm.TXOP_save_to_lvar, 0) // XXX this 0 must be pre-computed
  case parser.NodePrint:
    c.compile(ctx, n.(*parser.ListNode).Nodes[0])
    ctx.AppendOp(vm.TXOP_print)
  case parser.NodePrintRaw:
    c.compile(ctx, n.(*parser.ListNode).Nodes[0])
    ctx.AppendOp(vm.TXOP_print_raw)
  case parser.NodeForeach:
    ctx.AppendOp(vm.TXOP_pushmark)
    c.compile(ctx, n.(*parser.ForeachNode).List)
    ctx.AppendOp(vm.TXOP_for_start, 0)
    ctx.AppendOp(vm.TXOP_literal, 0)
    iter := ctx.AppendOp(vm.TXOP_for_iter, 0)
    pos  := ctx.ByteCode.Len()

    children := n.(*parser.ForeachNode).Nodes
    for _, v := range children {
      c.compile(ctx, v)
    }

    ctx.AppendOp(vm.TXOP_goto, -1 * (ctx.ByteCode.Len() - pos + 2))
    iter.SetArg(ctx.ByteCode.Len() - pos + 1)
    ctx.AppendOp(vm.TXOP_popmark)
  case parser.NodeIf:
    x := n.(*parser.IfNode)
    ctx.AppendOp(vm.TXOP_pushmark)
    c.compile(ctx, x.BooleanExpression)
    ifop := ctx.AppendOp(vm.TXOP_and, 0)
    pos := ctx.ByteCode.Len()

    var elseNode parser.Node
    children := x.ListNode.Nodes
    for _, child := range children {
      if child.Type() == parser.NodeElse {
        elseNode = child
      } else {
        c.compile(ctx, child)
      }
    }
    if elseNode == nil {
      ifop.SetArg(ctx.ByteCode.Len() - pos + 1)
    } else {
      // If we have an else, we need to put this AFTER the goto
      // that's generated by else
      ifop.SetArg(ctx.ByteCode.Len() - pos + 2)
      c.compile(ctx, elseNode)
    }


    ctx.AppendOp(vm.TXOP_popmark)
  case parser.NodeElse:
    gotoOp := ctx.AppendOp(vm.TXOP_goto, 0)
    pos := ctx.ByteCode.Len()
    for _, child := range n.(*parser.ElseNode).ListNode.Nodes {
      c.compile(ctx, child)
    }
    gotoOp.SetArg(ctx.ByteCode.Len() - pos + 1)
  case parser.NodeMakeArray:
    x := n.(*parser.MakeArrayNode)
    c.compile(ctx, x.Child)
    ctx.AppendOp(vm.TXOP_make_array)
  case parser.NodeRange:
    x := n.(*parser.RangeNode)
    ctx.AppendOp(vm.TXOP_literal, x.Start)
    ctx.AppendOp(vm.TXOP_move_to_sb)
    ctx.AppendOp(vm.TXOP_literal, x.End)
    ctx.AppendOp(vm.TXOP_range)
  case parser.NodeInt:
    x := n.(*parser.NumberNode)
    ctx.AppendOp(vm.TXOP_literal, x.Value.Int())
  case parser.NodeList:
    x := n.(*parser.ListNode)
    for _, v := range x.Nodes {
      c.compile(ctx, v)
      if v.Type() != parser.NodeRange {
        ctx.AppendOp(vm.TXOP_push)
      }
    }
  case parser.NodeFunCall:
    x := n.(*parser.FunCallNode)

    for _, child := range x.Args.Nodes {
      c.compile(ctx, child)
      ctx.AppendOp(vm.TXOP_push)
    }

    c.compile(ctx, x.Invocant)
    ctx.AppendOp(vm.TXOP_funcall)
  case parser.NodeInclude:
    x := n.(*parser.IncludeNode)

    c.compile(ctx, x.IncludeTarget)
    ctx.AppendOp(vm.TXOP_push)
    // Arguments to include (WITH foo = "bar") need to be evaulated
    // in the OUTER context, but the variables need to be set in the
    // include context
    if assignnodes := x.AssignmentNodes; len(assignnodes) > 0 {
      ctx.AppendOp(vm.TXOP_pushmark)
      for _, nv := range x.AssignmentNodes {
        v := nv.(*parser.AssignmentNode)
        ctx.AppendOp(vm.TXOP_literal, v.Assignee.Name)
        ctx.AppendOp(vm.TXOP_push)
        c.compile(ctx, v.Expression)
        ctx.AppendOp(vm.TXOP_push)
      }
      ctx.AppendOp(vm.TXOP_make_hash)
      ctx.AppendOp(vm.TXOP_move_to_sb)
      ctx.AppendOp(vm.TXOP_popmark)
    }
    ctx.AppendOp(vm.TXOP_pop)
    ctx.AppendOp(vm.TXOP_pushmark)
    ctx.AppendOp(vm.TXOP_include)
    ctx.AppendOp(vm.TXOP_popmark)
  default:
    fmt.Printf("Unknown node: %s\n", n.Type())
  }
}