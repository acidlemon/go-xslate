/*

Package vm implements the virtual machine used to run the bytecode
generated by http://github.com/lestrrat/go-xslate/compiler 

The virtual machine is an extremely simple one: each opcode in the
bytecode sequence returns the next opcode to execute. The virtual machine
just keeps on calling the opcode until we reach the "end" opcode.

The virtual machine accepts the bytecode, and input variables:

  vm.Run(bytecode, variables)

*/
package vm

import (
  "bytes"
  "io/ioutil"
)

type ByteCodeLoader interface {
  Load(string) (*ByteCode, error)
}

type VM struct {
  st *State
  Loader ByteCodeLoader
}

func NewVM() (*VM) {
  return &VM { NewState(), nil }
}

func (vm *VM) CurrentOp() *Op {
  return vm.st.CurrentOp()
}

func (vm *VM) Output() ([]byte, error) {
  return ioutil.ReadAll(vm.st.output)
}

func (vm *VM) OutputString() (string, error) {
  buf, err := vm.Output()
  if err != nil {
    return "", err
  }
  return string(buf), nil
}

func (vm *VM) Reset() {
  vm.st.opidx = 0
  vm.st.output = &bytes.Buffer {}
}

func (vm *VM) Run(bc *ByteCode, v Vars) {
  vm.Reset()
  st := vm.st
  if bc != nil {
    st.pc = bc
  }
  if v != nil {
    st.vars = v
  }
  st.Loader = vm.Loader
  for op := st.CurrentOp(); op.OpType() != TXOP_end; op = st.CurrentOp() {
    op.Call(st)
  }
}